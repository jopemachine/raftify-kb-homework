--- 

###### 공동 합

Raft의 메커니즘은 클러스터 내 서버들을 변경할 때 업데이트 기간 동안 서로 다른 설정들이 overlap 되는 `Joint consensus`라는 새로운 접근 방식을 사용한다.

Raft에서 클러스터는 우선 `Joint consensus`라고 불리는 중간 단계의 설정으로 전환한 후, `Joint consensus`가 커밋된 후 새 설정으 로 전이한다. `Joint consensus`는 구식 설정과 새 설정 양쪽을 합쳐서 구성된다.

- 로그 엔트리들은 양쪽 설정의 모든 서버들에 복제된다.
    
- 어느 쪽 설정의 서버든 리더로 선출될 수 있다.
    
- 리더 선출, 엔트리 커밋을 위해 구식 설정의 서버들과 새 설정의 서버들 각각은 별도의 다수의 서버들(_Majority_)의 합의가 필요하다.
    

`Joint consensus`는 각각의 서버들이 설정 사이를 각각 다른 시간에 안전하게 전이할 수 있도록 해 준다. 뿐만 아니라, 설정 파일 업데이트를 서비스 중단 없이 진행할 수 있게 만들어준다.

클러스터 설정은 복제된 로그에서 특별한 엔트리들을 사용해 저장되고 통신된다.

리더가 설정 파일을 변경하라는 요청을 받게 되면, `Joint consensus`를 위한 설정을 로그 엔트리로 저장하고 이전 섹션들에서 설명한 메커니즘을 사용하여 해당 엔트리를 복제한다.

한 번 서버가 새 설정 엔트리를 로그에 추가하고 나면, 서버는 해당 설정을 모든 미래의 결정들에 사용한다. (서버는 해당 엔트리가 커밋 되었는지 여부에 상관 없이 항상 자신의 로그의 최신 설정을 사용한다.)

이것은 리더가 `Joint consensus`가 커밋될 시기를 결정하기 위해, `Joint consensus`의 설정을 사용한다는 것을 의미한다.
\

![[Pasted image 20240720052227.png]]
(새 설정을 _C_new_, 구식 설정을 _C_old_, `Joint consensus`를 _C_old_new_라고 표현)

만약 리더에 장애가 발생하면 선출된 후보자가 _C_old_new_를 받았는지 여부에 따라 새로운 리더가 _C_old_ 또는 _C_old_new_ 내에서 선출될 수 있다.

어떤 케이스에도 _C_new_는 이 기간 동안 단독으로 의사 결정을 내릴 수 없다.

한 번 _C_old_new_가 커밋되고 나면, _C_old_, _C_new_ 양쪽 모두 다른 쪽의 동의 없이 의사 결정을 내릴 수 없으며, `Leader Completeness` 성질에 의해 오직 _C_old_new_ 로그를 가지고 있는 서버만 리더로 선출될 수 있다. `Joint consensus`가 커밋되었으니 이제 리더가 안전하게 _C_new_를 로그 엔트리로 만들고 클러스터에 복제할 수 있다. 해당 설정은 서버에서 발견되는대로 바로 적용된다.

_C_new_까지 커밋되고 나면 구식 설정은 무관한 설정으로 간주되며, 새 설정으로 업데이트 되지 않은 서버들은 종료될 수 있다.

위 그림에서 볼 수 있듯이 _C_old_와 _C_new_ 모두 단독으로 의사 결정을 내릴 수 있는 시기는 존재하지 않으며, 이 점이 안정성을 보장해준다.

설정 업데이트 자동화를 위해 다루어야 하는 몇 가지 이슈들이 더 있다.


## 설명

이 문서는 공동 합의 구현의 근거를 설명합니다.
섹션 6(클러스터 멤버십 변경)을 문자 그대로 분석하면

섹션의 각 문장은 색인화되고 요구 사항에 따라 구문 분석됩니다.
구현에 대한 제안 및 힌트.

## 분석

> **1** Raft에서 클러스터는 먼저 전환 구성으로 전환합니다.
> 공동 합의를 요청합니다. 일단 공동 합의가 이루어지면 시스템은
> 그런 다음 새 구성으로 전환됩니다.

모든 서버에는 구성에 대한 2단계 접근 방식이 있어야 합니다.
관리: 안정(C_old) 또는 불안정(C_old + C_old,new) 상태입니다.


> **2** 공동 합의는 이전 구성과 새 구성을 모두 결합합니다.
> **2a** 로그 항목은 두 구성의 모든 서버에 복제됩니다.

불안정한 C_old,new 상태에 있다는 것은 다음의 통합 집합에 요청을 보내는 것을 의미합니다.
C_old 및 C_new 서버.


> **2b** 두 구성의 모든 서버가 리더 역할을 할 수 있습니다.

_사실의 진술_


> **2c** 합의(선거 및 참가 약속)에는 과반수 찬성이 필요합니다.
> 이전 구성과 새 구성 모두.

불안정한 C_old,new 상태에 있다는 것은 변경 사항이 독립적으로 이루어져야 함을 의미합니다.
대부분의 C_old 서버와 C_new 서버에서 검증되었습니다.

````
  C_old C_new 결과 통과?
  A B C A B C D A+ B+ C- D- C_old+ C_new- => 실패
  A B C A B C D A+ B+ C- D+ C_old+ C_new+ => 통과
  A B C A B C D A+ B+ C+ D- C_old+ C_new+ => 통과
````

````
func (c *Configuration) Pass(votes map[uint64]bool) bool { ... }
````

지금까지 C_old,new에서 C_old 또는 C_new의 멤버십은
리더, 투표 집계 목적.


> **3** 아래에서 볼 수 있듯이 공동 합의를 통해 개별 서버는
> 타협하지 않고 서로 다른 시간에 구성 간 전환
> 안전.

_약속문_


> **4** 또한 공동 합의를 통해 클러스터가 계속 서비스를 제공할 수 있습니다.
> 구성 변경 전반에 걸쳐 클라이언트 요청.

클라이언트 요청(예: 명령)은 다음과 관계없이 항상 수락되어야 합니다.
공동 합의 상태.


> **5** 클러스터 구성은 특수 항목을 사용하여 저장되고 전달됩니다.
> 복제된 로그에서; 그림 9에서는 구성 변경 프로세스를 보여줍니다.

구성은 AppendEntries RPC를 통해 전달되어야 합니다.
구성은 마샬링 가능/비마샬 가능해야 합니다.
암시: 피어는 정렬 가능/비 정렬 가능해야 합니다.


> **6** 리더가 다음으로부터 구성 변경 요청을 받은 경우
> C_old ~ C_new, 공동 합의를 위한 구성(C_old,new
> 그림)을 로그 항목으로 저장하고 메커니즘을 사용하여 해당 항목을 복제합니다.
> 앞서 설명했습니다.

구성 변경 요청은 다음으로 전달되고 발송됩니다.
리더는 사용자 명령과 같습니다. 팔로어가 구성 변경을 가로챕니다.
명령을 실행하고 이를 사용하여 구성을 조작합니다.

handlerAppendEntries는 명령을 구성으로 역마샬링하려고 시도해야 합니다.
변화. 팔로어는 구성 변경 명령을 사용자에게 전파하지 않습니다.
상태 머신.


> **7** 특정 서버가 로그에 새 구성 항목을 추가하면 다음을 사용합니다.
> 향후 모든 결정을 위한 구성(입력을 기다리지 않음)
> 헌신하게 됩니다).

팔로어는 수신된 구성 변경 명령을 즉시 적용합니다. ㅏ
추종자는 적용 메커니즘으로 apply() 기능을 활용할 수 없습니다.
구성 변경.


> **8** 이는 리더가 C_old,new 규칙을 사용하여 다음을 결정한다는 의미입니다.
> C_old,new에 대한 로그 항목이 커밋될 때.

리더는 수신된 구성 변경 명령을 즉시 적용합니다.
아직 불안정한 상태가 아니라고 가정합니다(그렇지 않으면 거부).


> **9** 리더가 충돌하는 경우 C_old 또는 아래에서 새 리더가 선택될 수 있습니다.
> C_old,new, 당선자가 C_old,new를 수신했는지 여부에 따라 다름.

_사실의 진술_


> **10** 어떠한 경우에도 C_new는 이 기간 동안 일방적인 결정을 내릴 수 없습니다.

_사실의 진술_


> **11** C_old,new가 커밋되면 C_old나 C_new 모두 커밋할 수 없습니다.
> 상대방의 승인 없이 결정하고 리더 로그 속성을 보장합니다.
> C_old,new 로그 항목이 있는 서버만 리더로 선출될 수 있습니다.

_사실의 진술_


> **12** 이제 리더가 C_new를 설명하는 로그 항목을 생성하는 것이 안전합니다.
> 이를 클러스터에 복제합니다.

C_old에서 C_old로 구성 변경 명령이 실행되면 new가
커밋되면 리더는 C_old,new에서 C_new로 전환됩니다. 표준 적용()
이 동작에는 메커니즘을 활용할 수 있습니다.

구현: 구성 변경 항목이 변경되는 사용자 정의 Apply()를 가져옵니다.
리더 구성.


> **13** 다시 한번 말씀드리지만, 이 구성은 각 서버에 적용되는 즉시 적용됩니다.
>이 보입니다.

_사실의 진술_


> **14** C_new 규칙에 따라 새 구성이 커밋되면,
> 이전 구성은 관련이 없으며 서버는 새 구성에 포함되지 않습니다.
> 폐쇄될 수 있습니다.

서버가 구성 변경 명령을 수신하면
해당 명령이 다음과 같은 경우 서버 ID를 포함하지 않는 구성
커밋되면 자체적으로 종료되어야 합니다.

구현: 구성으로 인해 현재 서버가
추방되고 종료되면 '커밋된' 채널이 관련 채널에 주입됩니다.
LogEntry 및 리스너가 설치되었습니다. LogEntry가 커밋되면
리스너 고루틴은 서버 종료 신호를 보냅니다.


> **15** 그림 9에서 볼 수 있듯이 C_old와 C_new가 모두 가능한 경우는 없습니다.
> 일방적인 결정을 내립니다. 이는 안전을 보장합니다.

_사실의 진술_


> **16** 재구성을 위해 해결해야 할 두 가지 문제가 더 있습니다.

_약속문_


> **17** 첫째, 리더가 C_old의 일부이지만 C_new의 일부가 아닌 경우,
> 결국 퇴진.

_18의 접두사_


> **18** Raft에서는 리더가 임무를 수행한 후 즉시 내려옵니다.
> 자신을 포함하지 않는 구성 항목입니다.

이것이 새로운 구성 변경의 일부가 아니라는 사실을 알게 된 리더는 조치를 취해야 합니다.
해당 변경 사항을 커밋한 직후에 다운되지만 그 이전에는 그렇지 않습니다. 적용()
이 동작에는 메커니즘을 활용할 수 있습니다. **12**를 참조하세요. 하강하는 것은 가능하다
선택 루프를 종료하는 것과 동의어입니다. 추종자와 동일한 동작입니다.


> **19** 이는 일정 기간(커밋하는 동안)이 있음을 의미합니다.
> C_new) 여기서 리더는 자신을 포함하지 않는 클러스터를 관리합니다. 그것
> 로그 항목을 복제하지만 그 자체로 과반수로 계산되지는 않습니다.

리더는 다음과 같은 경우 자동으로 자신에게 투표하지 않도록 주의해야 합니다.
이를 포함하지 않는 [C_new] 상태의 대다수를 계산합니다.

구현: 투표 수를 계산할 때 실제 구성 범위를 초과합니다.
회원들을 대상으로 통과된 투표 집계와 비교합니다. 반대의 경우는 아닙니다.

> **20** C_new 멤버가 아니기 때문에 리더가 더 일찍 물러나면 안 됩니다.
> 여전히 당선될 수 있어 불필요한 선거가 발생할 수 있습니다.

_사실의 진술_


> **21** 두 번째 문제는 새 서버가 처음에 로그를 저장하지 않을 수 있다는 것입니다.
> 항목.

_사실의 진술_


> **22** 이 상태에서 클러스터에 추가하면 상당한 시간이 걸릴 수 있습니다.
> 따라잡는 동안, 그 시간 동안에는 불가능할 수도 있습니다.
> 새 로그 항목을 커밋합니다.

_사실의 진술_


> **23** 가용성 격차를 피하기 위해 Raft는 추가 기능을 도입합니다.
> 새 서버가 구성 변경 전 단계에 합류합니다.
> 투표권이 없는 구성원으로 클러스터(리더는 로그 항목을 구성원에게 복제합니다.
> 그러나 다수에게는 고려되지 않습니다).

이 동작은 제대로 지정되지 않았으며 안정적으로 구현할 수 없다고 생각합니다.
피어의 1차 속성인 일종의 센티널 값이 없습니다.
특히 이번 추격 단계에서 리더가 충돌하는 경우는 다음과 같습니다.
나에게는 명확하지 않습니다. 따라서 **저는 이 기능을 구현하지 않으며** 앞으로도 그렇게 하지 않을 것입니다.
내 머리 속에 바로 들어갈 수 있을 때까지.


> **24** 새 서버의 로그가 클러스터의 나머지 로그를 따라잡으면
> 위에서 설명한 대로 재구성을 진행할 수 있습니다.

위 참조.