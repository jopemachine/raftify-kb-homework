--- 

##### 스냅샷

스냅샷은 `Chubby`, `ZooKeeper` 등에서 사용되는 _Log Compaction_에 대한 가장 간단한 접근이다. 스냅샷은 현재 전체 시스템의 상태를 안정적 저장소에 기록하고, 이전까지의 전체 로그를 버린다.

아래 그림은 스냅샷의 기본적인 아이디어를 보여준다.
![[Pasted image 20240720052403.png]]

각각의 서버가 독립적으로 스냅샷을 유지하고 그들의 로그에서 커밋된 엔트리들을 처리한다.

Raft는 또한 스냅샷에 작은 양의 메타 데이터를 포함시킨다.

`Last included index`는 스냅샷에 포함될 가장 마지막 엔트리의 `index`이며, `Last included term`은 해당 엔트리의 `term` 값이다.

이 값들은 스냅샷 바로 이후의 엔트리에 대한 `AppendEntries` 일관성 검사를 돕기 위해 저장된다.

`Cluster membership change`를 위해 스냅샷은 로그 안에 마지막으로 포함된 `index`의 최신 클러스터 구성 설정도 포함한다.

서버가 스냅샷을 모두 쓰고나면 즉시 `Last included index`까지의 모든 로그 엔트리들과 이전 스냅샷을 제거할 수 있다.
### 동기화 문제

일반적으로 서버들이 독립적으로 스냅샷을 구성하지만, 리더는 때때로 지연이 생긴 팔로워들에게 스냅샷을 보내줘야 한다. 이런 상황은 리더가 팔로워에게 보내줘야 했던 다음 엔트리를 이미 제거해버린 경우 발생한다. 운 좋게도 이런 상황이 발생할 가능성은 낮다.

리더와 동기화 된 팔로워는 이미 이 엔트리를 갖고 있을 것이다. 그러나 굉장히 느린 팔로워나 새로 클러스터에 조인된 팔로워는 그렇지 않을 수 있다.

리더는 `InstallSnapshot`이라는 새로운 RPC를 통해 뒤쳐진 팔로워들에게 스냅샷을 보낸다.

팔로워가 이 RPC를 받으면 기존의 로그 엔트리들을 어떻게 처리해야 할 지 결정해야 한다. 대게 이 스냅샷은 팔로워의 스냅샷엔 들어 있지 않은 새로운 정보를 갖고 있다.

**이 경우 팔로워는 기존의 로그 전체를 버리게 된다. 기존의 모든 로그가 이 스냅샷에 의해 대체되며, 스냅샷과 충돌하는 커밋되지 않은 엔트리들이 있을 수도 있다.**

팔로워가 수신한 스냅샷이 재전송이나 실수로 인해 팔로워 로그의 Prefix에 해당한다면 스냅샷에 포함된 로그 엔트리들은 삭제하고, 스냅샷 뒤의 항목들은 여전히 유효하므로 유지해야 한다.

### 정당성

이러한 스냅샷 접근은 Raft의 _강한 리더 정책_(_Strong Leader Principle_)에서 출발한다. 팔로워들이 리더의 정보를 통해 스냅샷을 생성할 수 있기 때문이다.

리더를 갖는 것은 합의 도출에서 충돌이 발생하는 것을 피하도록 도와주는 반면, 스냅샷이 생성될 때 합의는 이미 도출되어 있으므로 의사 결정 충돌은 일어나지 않는다.

데이터는 여전히 리더에서 팔로워 단방향으로 흐른다. 단지 팔로워들은 이제 그들의 데이터를 재구성할 수 있다.

우리는 리더만이 스냅샷을 생성하고 각 팔로워들에게 복제하는 리더 중심의 접근 방법도 고려해보았다. 그러나 이런 접근 방법은 두 가지 문제가 있다.

1. 스냅샷을 각 팔로우들에게 모두 보내는 것은 네트워크 대역폭을 낭비하며 스냅샷 절차를 느려지게 만든다. 각 팔로워들은 이미 스냅샷을 생성하기 위한 그들만의 정보를 갖고 있으며, 일반적으로 리더가 로컬에 스냅샷을 생성하는 비용이 네트워크를 거쳐 스냅샷을 전달하는 비용보다 싸다.
    
2. 리더의 구현이 더 복잡해진다. 리더는 새로운 엔트리들을 복제하는 것과 동시에 그들에게 스냅샷을 보내야 한다.
    

### 성능 이슈

스냅샷 성능에 영향을 끼치는 두 개의 요소가 더 있다.

1. **서버들은 언제 스냅샷을 생성할 것인지 결정해야 한다.** 만약 너무 자주 스냅샷을 생성한다면 디스크 대역폭과 에너지를 낭비하게 되며, 반대로 스냅샷을 너무 가끔 생성하는 경우 스토리지 용량이 소진될 위험이 있고 로그를 재현(Replay)할 때 필요한 시간이 늘어나게 된다. 간단한 전략으로 로그 크기가 특정 바이트 수에 도달했을 때 스냅샷을 생성하는 방법이 있다. 만약 이 크기가 스냅샷의 예상되는 크기보다 좀 더 크게 설정된다면 스냅샷 생성을 위한 디스크 대역폭 오버헤드는 줄어들 것이다.
    
2. 두 번째 성능 이슈는 **스냅샷 생성이 상당한 양의 시간을 소요한다는 것**이다. 우리는 스냅샷 생성이 다른 연산을 지연시키는 것을 원하지 않는다. `Copy-On-Write` 전략을 사용하여 생성 중인 스냅샷에 영향을 끼치지 않고 새로운 업데이트들을 적용할 수 있다. 함수형 자료구조를 통해 설계한 상태 머신의 경우 본질적으로 `Copy-On-Write` 전략을 지원한다. 그 대안으로 OS 시스템의 `Copy-On-Write` 지원을 이용해 전체 상태 머신의 인메모리 스냅샷을 생성할 수도 있다.